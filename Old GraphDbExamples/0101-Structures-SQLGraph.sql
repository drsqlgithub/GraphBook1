use GraphDBTests
GO
/********************
Simple adjacency list
********************/

DROP PROCEDURE IF EXISTS SqlGraph.Company$Reparent;
DROP PROCEDURE IF EXISTS SqlGraph.Company$Delete;
DROP PROCEDURE IF EXISTS SqlGraph.Company$Insert;
DROP FUNCTION IF EXISTS SqlGraph.Company$returnHierarchyHelper;
DROP PROCEDURE IF EXISTS SqlGraph.Sale$InsertTestData;
DROP TABLE IF EXISTS SqlGraph.Sale;
DROP TABLE IF EXISTS SqlGraph.ReportsTo;
DROP TABLE IF EXISTS SqlGraph.Company;
DROP SEQUENCE IF EXISTS SqlGraph.CompanyDataGenerator_SEQUENCE;

/*
In this chapter we are going to implement a tree using SQL Server graph tables using a very simple structure. Using this same basic structure, I will implement several different methods of implementing a graph using SQL Server tables, starting with the one that fits the main theme of this book, node and edge tables in SQL Server. In this chapter we will do a variety of tasks, starting with maintaining the structure, then doing some text operations with the structure. 
*/

----------------------------------------------------------------------------------------------------------
--*****
--Maintaining the structure
--*****
----------------------------------------------------------------------------------------------------------

--to get started, I am going to create a schema with a few tables. The schema is named for the algorithm/pattern we are using, because it will let me vary the pattern in multiple ways for different methods of implementing a tree. As mentioned back in Chapter 2, thee are a number of method that I wil cover in varying levels of detail. I will spend this chapter on the SQL graph method, then cover the other methods in the next chapter in brief (While the exact same stored procedures for loading the structures will be in the downloads, including all of the test scripts, I will only discuss them at a hight level.

DROP SCHEMA IF EXISTS SqlGraph;
GO

CREATE SCHEMA SqlGraph;
GO


--The Company table is going to be the simplest possible. However, consider this object to be analagous to your typical customer table in your database. All the other attributes you might want in your table you should add. Headquarter addresse, nickname, whatever has a 1-1 cardinality with the concept of a company you might be modeling. This could really be anything too. A person, a management hierarchy, whatever you might build a tree to implement. My object will strictly have a unique, autogenerated integer, and a name. Both of these will have uniqueness constraints, and the surrogate integer key (CompanyId) will be the clustering key. Unlike a simple adjacency list, which might contain a column named like "ParentCompanyId" to indicate the hierarchy, as we have seen using SQL Graph objects in the previous chapters, the graph structures will be in a seperate, edge, table.
CREATE TABLE SqlGraph.Company
(
    CompanyId       INT         IDENTITY(1, 1) CONSTRAINT PKCompany PRIMARY KEY,
    Name            VARCHAR(20) NOT NULL CONSTRAINT AKCompany_Name UNIQUE,
) AS NODE;

--Creating the edge for a tree (as it will for a bill of materials directed acyclic graph) will all be links from a node to a node. In the edge, I will not include any columns in the edge, but you might in a real table want to include at least the time when the row was created, and maybe a time when the relationship was established (which might be the same time, but likely should not be the same column (since the relationship might have been established earlier than the row was actually created. Even on the web you might want data to go through some workflow before being inserted into your main database. Keeping this simple will just simply keep the example simple.
CREATE TABLE SqlGraph.ReportsTo
(
	CONSTRAINT EC_ReportsTo$DefinesParentOf CONNECTION (SqlGraph.Company TO SqlGraph.Company) ON DELETE NO ACTION
)
AS EDGE;
GO

--Next, I am going to add a few indexes to support queries. The first is the clustered index, and for this structure I am going to cluster the table on the $to_id value. This is because the most expensive queries will be fetching rows based on the $to_id when doing breadth first queries. I am going to make it a UNIQUE constraint because for this object to be a strict tree, each $to_id should only show up once in the structure. (Note that you could implement multiple trees by adding a name for the specific structures in the object and including it in the index. I won't do that as any specific example because the code is very much the same, except for filtering on the tree you are working with. Using column values to add structures like that is less efficient, but definitely more flexible than needing a new edge object for each individual strucuture.

ALTER TABLE SqlGraph.ReportsTo ADD CONSTRAINT AKReportsTo UNIQUE CLUSTERED ($from_id,$to_id);
CREATE UNIQUE INDEX FromId ON SqlGraph.ReportsTo($to_id);

--There will be two specific demonstrations of performance I wil be showing that you will likely need for many of your tree objects. The first is summing activity of child objects. This is analagous to a company that has sales in multiple regions. And each regions have subregions and so on down to different locations. The second scenario is finding out if you have a child in the hierarchy, and who your predecessors are in the structure. I will use my simulated data structure to demonstrate each of these scenarios. (Not only with SQL Graph, but the exact same scenarios with each algorithm with varying amounts of data)

--The following object is simply used to generate a Company some sales that are the same in every case to make the demo a bit complicated. There will be a stored procedure to create each node, and to add sales to certain nodes (in my demonstration code, it is all of the leaf nodes). Because I assign sales sequentially, and in the same number each time, all of the example output is the same.


CREATE SEQUENCE SqlGraph.CompanyDataGenerator_SEQUENCE
AS int
START WITH 1;
GO

CREATE TABLE SqlGraph.Sale
(
    SalesId           int            NOT NULL IDENTITY(1, 1) CONSTRAINT PKSale PRIMARY KEY,
    TransactionNumber varchar(10)    NOT NULL CONSTRAINT AKSale UNIQUE,
    Amount            numeric(12, 2) NOT NULL,
    CompanyId         int            NOT NULL CONSTRAINT FK_Sale_ref_Company REFERENCES SqlGraph.Company(CompanyId),
	INDEX XCompanyId (CompanyId, Amount)
);
GO



--the sale table is here for when we do aggregations to make the situation more "real". Note that I just use a sequential number for the Amount multiplied by .25. 

CREATE PROCEDURE SqlGraph.Sale$InsertTestData
    @Name     varchar(20), --Note that all procs use natural keys to make it easier for you to work with manually.
                           --If you are implementing this for a tool to manipulate, use the surrogate keys
    @RowCount int = 5
AS
BEGIN
	SET NOCOUNT ON;

	WHILE @RowCount > 0
	BEGIN
		INSERT INTO SqlGraph.Sale(TransactionNumber, Amount, CompanyId)
		SELECT CAST(NEXT VALUE FOR SqlGraph.CompanyDataGenerator_SEQUENCE AS varchar(10)),
			   .25 * CAST(NEXT VALUE FOR SqlGraph.CompanyDataGenerator_SEQUENCE AS numeric(12, 2)),
			   (   SELECT Company.CompanyId
				   FROM   SqlGraph.Company
				   WHERE  Company.Name = @Name);

		SET @RowCount = @RowCount - 1;
	END;
 END;
GO
